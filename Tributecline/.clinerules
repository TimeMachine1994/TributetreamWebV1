Project Context
We are building Tribuestream.com, a SvelteKit 5 UI front end that communicate with a wordpress backend via REST API's. We have a custom plugin installed in out wordpress that exposes certain routes, along with the JWT Auth extension.

Understanding SveltekIt 5:
Key points about Svelte 5 in SvelteKit 5:
Runes for reactivity:
Reactive variables are declared using $state instead of simply let, giving more explicit control over what is reactive. 
Snippets for component composition:
Components receive content through snippets, offering greater flexibility than traditional slots. 
Improved TypeScript support:
Native TypeScript integration within the Svelte syntax. 
More granular reactivity:
The new reactivity system allows for more fine-grained updates, potentially improving performance. 
Important considerations:
Migration required:
Moving from SvelteKit 4 to SvelteKit 5 might require code changes due to the significant Svelte 5 updates. 
Backwards compatibility:
While Svelte 5 components can render Svelte 4 components, mixing the two within a single component is not possible. 


Code Style and Structure
Write concise, technical TypeScript code with accurate examples

Use functional and declarative programming patterns; avoid classes

Prefer iteration and modularization over code duplication

Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)

Always put comments in the code to explain why and how.


Structure repository files as follows:

A typical SvelteKit project has a defined structure, as outlined in the "Project structure • Docs • Svelte". The key directories and files include:
•
src: This directory holds the core of your project.
◦
lib: Contains your library code, including utilities and components. It can be imported via the $lib alias. The $lib/server alias is for server-only code, which SvelteKit prevents from being imported in client code.
◦
params: Contains param matchers.
◦
routes: Holds the routes of your application. Components used only within a single route can also be placed here.
◦
app.html: This is your page template, which includes placeholders like %sveltekit.head% for <link> and <script> elements, %sveltekit.body% for the rendered page markup, %sveltekit.assets% for paths to assets, %sveltekit.nonce% for CSP nonce, and %sveltekit.env.[NAME]% for environment variables.
◦
error.html: The page rendered when errors occur, containing placeholders like %sveltekit.status% for the HTTP status and %sveltekit.error.message% for the error message.
◦
hooks.client.js: Contains your client hooks.
◦
hooks.server.js: Contains your server hooks.
◦
service-worker.js: Contains your service worker.
•
static: This directory is for static assets served as-is, such as robots.txt or favicon.png.
•
tests: This directory contains your tests, particularly if you've added Playwright for browser testing.
•
package.json: This file lists dependencies, including @sveltejs/kit, svelte, and vite as devDependencies. It also includes "type": "module", which means .js files are treated as native JavaScript modules.
•
svelte.config.js: Contains your Svelte and SvelteKit configuration.
•
tsconfig.json: Configures TypeScript, extending SvelteKit's generated .svelte-kit/tsconfig.json.
•
vite.config.js: This is a Vite project file that uses the @sveltejs/kit/vite plugin.
Additionally, SvelteKit generates files in the .svelte-kit directory during development and building, which can be ignored and deleted.

Tech Stack
SvelteKit 5

TypeScript

Tailwind CSS

Wordpress PHP Plugins

MYSQL

Naming Conventions
Use lowercase with dashes for directories (e.g., components/form-wizard)

Favor named exports for components and utilities

Use PascalCase for component files (e.g., VisaForm.tsx)

Use camelCase for utility files (e.g., formValidator.ts)

TypeScript Usage
Use TypeScript for all code; prefer interfaces over types

Avoid enums; use const objects with 'as const' assertion

Use functional components with TypeScript interfaces

Define strict types for message passing between different parts of the extension

Avoid try/catch blocks unless there's good reason to translate or handle error in that abstraction

Use explicit return types for all functions

When table or field are missing in mysql, give me the sql command to create them in the output.

Project Documentation
You are my assistant, an expert software engineer who periodically loses all memory of your work. Before each memory loss or when i ask it, you maintain a set of high-level context files that help you understand and continue development. You are highly skilled in:

System architecture and development patterns

Product strategy and engineering

Technical decision-making and problem-solving

Building MVPs: you choose to build what is simple and fast over what is complicated and verbose

Your memory loss is actually an advantage - it forces you to maintain perfect documentation and validate all assumptions.

Context System
Core Files
Maintain these files in client_docs/:

productContext.md 
- Why we're building this 
- Core user problems/solutions 
- Key workflows 
- Product direction and priorities 

activeContext.md 
- Current focus/issues 
- Recent changes 
- Active files 
- Next steps 
(This is your source of truth for any conflicts) 

systemPatterns.md 
- High-level architecture 
- Core technical patterns 
- Data flow 
- Key technical decisions 

developmentWorkflow.md 
- How we work on this specific project 
- Testing patterns 
- Release process 
- Project-specific standards 

operationalContext.md 
- How the system runs 
- Error handling patterns 
- Infrastructure details 
- Performance requirements 

projectBoundaries.md 
- Technical constraints 
- Scale requirements 
- Hard limitations 
- Non-negotiables 

techContext.md 
- Core technologies used 
- Integration patterns 
- Key libraries/frameworks 
- Infrastructure choices 
- Technical constraints 
- Development environment 

currentTasks.md
this one is different from the others, it is a list of tasks that are currently in progress.
this will be updated when i ask it to be updated or referenced.
- Explanation of what need to be achieved 
- Explanation of what is already achieved 
- Explanation of what is blocked 
- Explanation of what is in progress 
- Explanation of what is next 
- Functions, pages, components, types, etc. already created for that task
- When a task is completed, add a ✅ in front of the task.
- When a task is blocked, add a ❌ in front of the task.
- When a task is in progress, add a ⚙️ in front of the task.
- When a task is not started, add a ⚠️ in front of the task.
File Structure
Each file should:

Focus on high-level understanding over technical details

Explain why decisions were made

Cross-reference other files when needed

Stay current with project changes; ALWAYS note the last updated date at the top of these context files when making updates

Automatically suggest additions for .clinerules files where best practices are used during the generation.

You are an expert in Svelte 5, SvelteKit, TypeScript, and modern web development.

Key Principles
- Write concise, technical code with accurate Svelte 5 and SvelteKit examples.
- Leverage SvelteKit's server-side rendering (SSR) and static site generation (SSG) capabilities.
- Prioritize performance optimization and minimal JavaScript for optimal user experience.
- Use descriptive variable names and follow Svelte and SvelteKit conventions.
- Organize files using SvelteKit's file-based routing system.

Code Style and Structure
- Write concise, technical TypeScript or JavaScript code with accurate examples.
- Use functional and declarative programming patterns; avoid unnecessary classes except for state machines.
- Prefer iteration and modularization over code duplication.
- Structure files: component logic, markup, styles, helpers, types.
- Follow Svelte's official documentation for setup and configuration: https://svelte.dev/docs

Naming Conventions
- Use lowercase with hyphens for component files (e.g., `components/auth-form.svelte`).
- Use PascalCase for component names in imports and usage.
- Use camelCase for variables, functions, and props.

TypeScript Usage
- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use const objects instead.
- Use functional components with TypeScript interfaces for props.
- Enable strict mode in TypeScript for better type safety.

Svelte Runes
- `$state`: Declare reactive state
  ```typescript
  let count = $state(0);
  ```
- `$derived`: Compute derived values
  ```typescript
  let doubled = $derived(count * 2);
  ```
- `$effect`: Manage side effects and lifecycle
  ```typescript
  $effect(() => {
    console.log(`Count is now ${count}`);
  });
  ```
- `$props`: Declare component props
  ```typescript
  let { optionalProp = 42, requiredProp } = $props();
  ```
- `$bindable`: Create two-way bindable props
  ```typescript
  let { bindableProp = $bindable() } = $props();
  ```
- `$inspect`: Debug reactive state (development only)
  ```typescript
  $inspect(count);
  ```

UI and Styling
- Use Tailwind CSS for utility-first styling approach.
- Leverage Shadcn components for pre-built, customizable UI elements.
- Import Shadcn components from `$lib/components/ui`.
- Organize Tailwind classes using the `cn()` utility from `$lib/utils`.
- Use Svelte's built-in transition and animation features.

Shadcn Color Conventions
- Use `background` and `foreground` convention for colors.
- Define CSS variables without color space function:
  ```css
  --primary: 222.2 47.4% 11.2%;
  --primary-foreground: 210 40% 98%;
  ```
- Usage example:
  ```svelte
  <div class="bg-primary text-primary-foreground">Hello</div>
  ```
- Key color variables:
  - `--background`, `--foreground`: Default body colors
  - `--muted`, `--muted-foreground`: Muted backgrounds
  - `--card`, `--card-foreground`: Card backgrounds
  - `--popover`, `--popover-foreground`: Popover backgrounds
  - `--border`: Default border color
  - `--input`: Input border color
  - `--primary`, `--primary-foreground`: Primary button colors
  - `--secondary`, `--secondary-foreground`: Secondary button colors
  - `--accent`, `--accent-foreground`: Accent colors
  - `--destructive`, `--destructive-foreground`: Destructive action colors
  - `--ring`: Focus ring color
  - `--radius`: Border radius for components

SvelteKit Project Structure
- Use the recommended SvelteKit project structure:
  ```
  - src/
    - lib/
    - routes/
    - app.html
  - static/
  - svelte.config.js
  - vite.config.js
  ```

Component Development
- Create .svelte files for Svelte components.
- Use .svelte.ts files for component logic and state machines.
- Implement proper component composition and reusability.
- Use Svelte's props for data passing.
- Leverage Svelte's reactive declarations for local state management.

State Management
- Use classes for complex state management (state machines):
  ```typescript
  // counter.svelte.ts
  class Counter {
    count = $state(0);
    incrementor = $state(1);
    
    increment() {
      this.count += this.incrementor;
    }
    
    resetCount() {
      this.count = 0;
    }
    
    resetIncrementor() {
      this.incrementor = 1;
    }
  }

  export const counter = new Counter();
  ```
- Use in components:
  ```svelte
  <script lang="ts">
  import { counter } from './counter.svelte.ts';
  </script>

  <button on:click={() => counter.increment()}>
    Count: {counter.count}
  </button>
  ```

Routing and Pages
- Utilize SvelteKit's file-based routing system in the src/routes/ directory.
- Implement dynamic routes using [slug] syntax.
- Use load functions for server-side data fetching and pre-rendering.
- Implement proper error handling with +error.svelte pages.

Server-Side Rendering (SSR) and Static Site Generation (SSG)
- Leverage SvelteKit's SSR capabilities for dynamic content.
- Implement SSG for static pages using prerender option.
- Use the adapter-auto for automatic deployment configuration.

Performance Optimization
- Leverage Svelte's compile-time optimizations.
- Use `{#key}` blocks to force re-rendering of components when needed.
- Implement code splitting using dynamic imports for large applications.
- Profile and monitor performance using browser developer tools.
- Use `$effect.tracking()` to optimize effect dependencies.
- Minimize use of client-side JavaScript; leverage SvelteKit's SSR and SSG.
- Implement proper lazy loading for images and other assets.

Data Fetching and API Routes
- Use load functions for server-side data fetching.
- Implement proper error handling for data fetching operations.
- Create API routes in the src/routes/api/ directory.
- Implement proper request handling and response formatting in API routes.
- Use SvelteKit's hooks for global API middleware.

SEO and Meta Tags
- Use Svelte:head component for adding meta information.
- Implement canonical URLs for proper SEO.
- Create reusable SEO components for consistent meta tag management.

Forms and Actions
- Utilize SvelteKit's form actions for server-side form handling.
- Implement proper client-side form validation using Svelte's reactive declarations.
- Use progressive enhancement for JavaScript-optional form submissions.

Internationalization (i18n) with Paraglide.js
- Use Paraglide.js for internationalization: https://inlang.com/m/gerre34r/library-inlang-paraglideJs
- Install Paraglide.js: `npm install @inlang/paraglide-js`
- Set up language files in the `languages` directory.
- Use the `t` function to translate strings:
  ```svelte
  <script>
  import { t } from '@inlang/paraglide-js';
  </script>

  <h1>{t('welcome_message')}</h1>
  ```
- Support multiple languages and RTL layouts.
- Ensure text scaling and font adjustments for accessibility.

Accessibility
- Ensure proper semantic HTML structure in Svelte components.
- Implement ARIA attributes where necessary.
- Ensure keyboard navigation support for interactive elements.
- Use Svelte's bind:this for managing focus programmatically.

Key Conventions
1. Embrace Svelte's simplicity and avoid over-engineering solutions.
2. Use SvelteKit for full-stack applications with SSR and API routes.
3. Prioritize Web Vitals (LCP, FID, CLS) for performance optimization.
4. Use environment variables for configuration management.
5. Follow Svelte's best practices for component composition and state management.
6. Ensure cross-browser compatibility by testing on multiple platforms.
7. Keep your Svelte and SvelteKit versions up to date.

Documentation
- Svelte 5 Runes: https://svelte-5-preview.vercel.app/docs/runes
- Svelte Documentation: https://svelte.dev/docs
- SvelteKit Documentation: https://kit.svelte.dev/docs
- Paraglide.js Documentation: https://inlang.com/m/gerre34r/library-inlang-paraglideJs/usage

Refer to Svelte, SvelteKit, and Paraglide.js documentation for detailed information on components, internationalization, and best practices.

Understanding Wordpress JWT AUth: 
Namespace and Endpoints
When the plugin is activated, a new namespace is added

/jwt-auth/v1
Also, two new endpoints are added to this namespace

Endpoint | HTTP Verb
/wp-json/jwt-auth/v1/token | POST
/wp-json/jwt-auth/v1/token/validate | POST

USAGE
/wp-json/jwt-auth/v1/token
This is the entry point for the JWT Authentication.

Validates the user credentials, username and password, and returns a token to use in a future request to the API if the authentication is correct or error if the authentication fails.

Sample request using AngularJS
( function() {

  var app = angular.module( 'jwtAuth', [] );

  app.controller( 'MainController', function( $scope, $http ) {

    var apiHost = 'http://yourdomain.com/wp-json';

    $http.post( apiHost + '/jwt-auth/v1/token', {
        username: 'admin',
        password: 'password'
      } )

      .then( function( response ) {
        console.log( response.data )
      } )

      .catch( function( error ) {
        console.error( 'Error', error.data[0] );
      } );

  } );

} )();
Success response from the server

{
    "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9qd3QuZGV2IiwiaWF0IjoxNDM4NTcxMDUwLCJuYmYiOjE0Mzg1NzEwNTAsImV4cCI6MTQzOTE3NTg1MCwiZGF0YSI6eyJ1c2VyIjp7ImlkIjoiMSJ9fX0.YNe6AyWW4B7ZwfFE5wJ0O6qQ8QFcYizimDmBy6hCH_8",
    "user_display_name": "admin",
    "user_email": "admin@localhost.dev",
    "user_nicename": "admin"
}
Error response from the server

{
    "code": "jwt_auth_failed",
    "data": {
        "status": 403
    },
    "message": "Invalid Credentials."
}
Once you get the token, you must store it somewhere in your application, ex. in a cookie or using localstorage.

From this point, you should pass this token to every API call

Sample call using the Authorization header using AngularJS

app.config( function( $httpProvider ) {
  $httpProvider.interceptors.push( [ '$q', '$location', '$cookies', function( $q, $location, $cookies ) {
    return {
      'request': function( config ) {
        config.headers = config.headers || {};
        //Assume that you store the token in a cookie.
        var globals = $cookies.getObject( 'globals' ) || {};
        //If the cookie has the CurrentUser and the token
        //add the Authorization header in each request
        if ( globals.currentUser && globals.currentUser.token ) {
          config.headers.Authorization = 'Bearer ' + globals.currentUser.token;
        }
        return config;
      }
    };
  } ] );
} );
The wp-api-jwt-auth will intercept every call to the server and will look for the Authorization Header, if the Authorization header is present will try to decode the token and will set the user according with the data stored in it.

If the token is valid, the API call flow will continue as always.

Sample Headers

POST /resource HTTP/1.1
Host: server.example.com
Authorization: Bearer mF_s9.B5f-4.1JqM
ERRORS
If the token is invalid an error will be returned, here are some samples of errors.

Invalid Credentials

[
  {
    "code": "jwt_auth_failed",
    "message": "Invalid Credentials.",
    "data": {
      "status": 403
    }
  }
]
Invalid Signature

[
  {
    "code": "jwt_auth_invalid_token",
    "message": "Signature verification failed",
    "data": {
      "status": 403
    }
  }
]
Expired Token

[
  {
    "code": "jwt_auth_invalid_token",
    "message": "Expired token",
    "data": {
      "status": 403
    }
  }
]
/wp-json/jwt-auth/v1/token/validate
This is a simple helper endpoint to validate a token; you only will need to make a POST request sending the Authorization header.

Valid Token Response

{
  "code": "jwt_auth_valid_token",
  "data": {
    "status": 200
  }
}
AVAILABLE HOOKS
The wp-api-jwt-auth is dev friendly and has five filters available to override the default settings.

jwt_auth_cors_allow_headers
The jwt_auth_cors_allow_headers allows you to modify the available headers when the CORs support is enabled.

Default Value:

'Access-Control-Allow-Headers, Content-Type, Authorization'
jwt_auth_not_before
The jwt_auth_not_before allows you to change the nbf value before the token is created.

Default Value:

Creation time - time()
jwt_auth_expire
The jwt_auth_expire allows you to change the value exp before the token is created.

Default Value:

time() + (DAY_IN_SECONDS * 7)
jwt_auth_token_before_sign
The jwt_auth_token_before_sign allows you to modify all the token data before to be encoded and signed.

Default Value

<?php
$token = array(
    'iss' => get_bloginfo('url'),
    'iat' => $issuedAt,
    'nbf' => $notBefore,
    'exp' => $expire,
    'data' => array(
        'user' => array(
            'id' => $user->data->ID,
        )
    )
);
jwt_auth_token_before_dispatch
The jwt_auth_token_before_dispatch allows you to modify all the response array before to dispatch it to the client.

Default Value:

<?php
$data = array(
    'token' => $token,
    'user_email' => $user->data->user_email,
    'user_nicename' => $user->data->user_nicename,
    'user_display_name' => $user->data->display_name,
);
jwt_auth_algorithm
The jwt_auth_algorithm allows you to modify the signing algorithm.

Default value:

<?php
$token = JWT::encode(
    apply_filters('jwt_auth_token_before_sign', $token, $user),
    $secret_key,
    apply_filters('jwt_auth_algorithm', 'HS256')
);

// ...

$token = JWT::decode(
    $token,
    new Key($secret_key, apply_filters('jwt_auth_algorithm', 'HS256'))
);